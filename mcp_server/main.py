# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:13:29+00:00



import argparse
import json
import os
from typing import *
from typing import Optional

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Path, Query

from models import (
    Interpolation,
    LocationDescriptor,
    OutputFormat,
    OutputSRS,
    StreetDirection,
    UnitDesignator,
)

app = MCPProxy(
    contact={
        'name': 'Contact DataBC',
        'url': 'https://dpdd.atlassian.net/servicedesk/customer/portal/1/group/7/',
    },
    description='This API represents address cleaning, correction, completion, geocoding, reverse geocoding, and proximity resources for intersection addresses, physical addresses and their occupants in British Columbia. Please read our [data collection notice](https://github.com/bcgov/api-specs/blob/master/COLLECTION_NOTICE.md#collection-notice).  \n\nPlease note that you may experience issues when submitting requests to the delivery or test environment if using this [OpenAPI specification](https://github.com/bcgov/api-specs) in other API console viewers. \n\n[API keys](https://api.gov.bc.ca/devportal/api-directory/273) are unique and can be acquired with a GitHub or IDIR account. \n\n **Notification:** If you have applications or web pages that link to the BC Address Geocoder you must use the following URL. \n\n *https://geocoder.api.gov.bc.ca* \n\n Please note that the following URLs were deprecated in September 2018 [More Details](https://www2.gov.bc.ca/gov/content?id=103ADC5A956842828554238DEF28D6E5). \n\n - http://apps.gov.bc.ca/pub/geocoder \n - https://apps.gov.bc.ca/pub/geocoder\n\\\n\\\n ',
    license={
        'name': 'Open Government License - British Columbia',
        'url': 'https://www2.gov.bc.ca/gov/content?id=A519A56BC2BF44E4A008B33FCF527F61',
    },
    termsOfService='https://www2.gov.bc.ca/gov/content?id=D1EE0A405E584363B205CD4353E02C88',
    title='Geocoder REST API',
    version='2.0.0',
    servers=[
        {'description': 'Production (gated)', 'url': 'https://geocoder.api.gov.bc.ca/'},
        {'description': 'Test (gated)', 'url': 'https://geocodertst.api.gov.bc.ca/'},
        {
            'description': 'Delivery (gated)',
            'url': 'https://geocoderdlv.api.gov.bc.ca/',
        },
    ],
)


@app.get(
    '/addresses.{outputFormat}',
    description=""" Represents the set of geocoded and standardized sites and intersections whose address best matches a given query address. """,
    tags=['address_geocoding'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_addresses__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    address_string: Optional[str] = Query(None, alias='addressString'),
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    max_results: Optional[int] = Query(1, alias='maxResults'),
    interpolation: Optional[Interpolation] = 'adaptive',
    echo: Optional[bool] = True,
    brief: Optional[bool] = False,
    auto_complete: Optional[bool] = Query(False, alias='autoComplete'),
    set_back: Optional[int] = Query(0, alias='setBack'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    min_score: Optional[int] = Query(1, alias='minScore'),
    match_precision: Optional[str] = Query(None, alias='matchPrecision'),
    match_precision_not: Optional[str] = Query(None, alias='matchPrecisionNot'),
    site_name: Optional[str] = Query(None, alias='siteName'),
    unit_designator: Optional[UnitDesignator] = Query(None, alias='unitDesignator'),
    unit_number: Optional[str] = Query(None, alias='unitNumber'),
    unit_number_suffix: Optional[str] = Query(None, alias='unitNumberSuffix'),
    civic_number: Optional[str] = Query(None, alias='civicNumber'),
    civic_number_suffix: Optional[str] = Query(None, alias='civicNumberSuffix'),
    street_name: Optional[str] = Query(None, alias='streetName'),
    street_type: Optional[str] = Query(None, alias='streetType'),
    street_direction: Optional[StreetDirection] = Query(None, alias='streetDirection'),
    street_qualifier: Optional[str] = Query(None, alias='streetQualifier'),
    locality_name: Optional[str] = Query(None, alias='localityName'),
    province_code: Optional[str] = Query('BC', alias='provinceCode'),
    localities: Optional[str] = None,
    not_localities: Optional[str] = Query(None, alias='notLocalities'),
    bbox: Optional[str] = None,
    centre: Optional[str] = None,
    max_distance: Optional[float] = Query(None, alias='maxDistance'),
    extrapolate: Optional[bool] = None,
    parcel_point: Optional[str] = Query(None, alias='parcelPoint'),
):
    """
    Geocode an address
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/intersections/near.{outputFormat}',
    description=""" Represents intersections near a given point """,
    tags=['intersection_search', 'site_search'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_intersections_near__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    point: str = ...,
    max_distance: Optional[int] = Query(None, alias='maxDistance'),
    output_s_r_s: OutputSRS = Query(..., alias='outputSRS'),
    max_results: Optional[int] = Query(1, alias='maxResults'),
    min_degree: Optional[int] = Query(2, alias='minDegree'),
    max_degree: Optional[int] = Query(100, alias='maxDegree'),
):
    """
    Find intersections near to a geographic point
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/intersections/nearest.{outputFormat}',
    description=""" Represents the closest intersection to a given point """,
    tags=['intersection_search'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_intersections_nearest__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    point: str = ...,
    max_distance: Optional[int] = Query(None, alias='maxDistance'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    min_degree: Optional[int] = Query(2, alias='minDegree'),
    max_degree: Optional[int] = Query(100, alias='maxDegree'),
):
    """
    Find nearest intersection to a geographic point
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/intersections/within.{outputFormat}',
    description=""" Represents all intersections within a given area """,
    tags=['intersection_search', 'site_search'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_intersections_within__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    bbox: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    max_results: Optional[int] = Query(200, alias='maxResults'),
    min_degree: Optional[int] = Query(2, alias='minDegree'),
    max_degree: Optional[int] = Query(100, alias='maxDegree'),
):
    """
    Find intersections in a geographic area
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/intersections/{intersectionID}.{outputFormat}',
    description=""" Represents a individual intersection """,
    tags=['intersection_search'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_intersections__intersection_i_d__output_format(
    intersection_i_d: str = Path(..., alias='intersectionID'),
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
):
    """
    Get an intersection by its unique ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/occupants/addresses.{outputFormat}',
    description=""" Represents the set of occupants whose addresses best match a given query address. Every occupant has an associated site which has a standardized address and a coordinate location on the Earth. """,
    tags=['address_geocoding', 'site_search', 'occupant_information'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_occupants_addresses__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    address_string: Optional[str] = Query(None, alias='addressString'),
    tags: Optional[str] = None,
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    max_results: Optional[int] = Query(1, alias='maxResults'),
    interpolation: Optional[Interpolation] = 'adaptive',
    echo: Optional[bool] = False,
    brief: Optional[bool] = False,
    auto_complete: Optional[bool] = Query(False, alias='autoComplete'),
    set_back: Optional[int] = Query(0, alias='setBack'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    min_score: Optional[int] = Query(1, alias='minScore'),
    match_precision: Optional[str] = Query('OCCUPANT', alias='matchPrecision'),
    match_precision_not: Optional[str] = Query(None, alias='matchPrecisionNot'),
    site_name: Optional[str] = Query(None, alias='siteName'),
    unit_designator: Optional[UnitDesignator] = Query(None, alias='unitDesignator'),
    unit_number: Optional[str] = Query(None, alias='unitNumber'),
    unit_number_suffix: Optional[str] = Query(None, alias='unitNumberSuffix'),
    civic_number: Optional[str] = Query(None, alias='civicNumber'),
    civic_number_suffix: Optional[str] = Query(None, alias='civicNumberSuffix'),
    street_name: Optional[str] = Query(None, alias='streetName'),
    street_type: Optional[str] = Query(None, alias='streetType'),
    street_direction: Optional[StreetDirection] = Query(None, alias='streetDirection'),
    street_qualifier: Optional[str] = Query(None, alias='streetQualifier'),
    locality_name: Optional[str] = Query(None, alias='localityName'),
    province_code: Optional[str] = Query('BC', alias='provinceCode'),
    localities: Optional[str] = None,
    not_localities: Optional[str] = Query(None, alias='notLocalities'),
    bbox: Optional[str] = None,
    centre: Optional[str] = None,
    max_distance: Optional[float] = Query(None, alias='maxDistance'),
    extrapolate: Optional[bool] = None,
    parcel_point: Optional[str] = Query(None, alias='parcelPoint'),
):
    """
    Geocode an address and identify site occupants
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/occupants/near.{outputFormat}',
    description=""" Represents occupants near a given point in order of closest to farthest """,
    tags=['site_search', 'occupant_information'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_occupants_near__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    point: str = ...,
    tags: Optional[str] = None,
    max_distance: Optional[int] = Query(None, alias='maxDistance'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    max_results: Optional[int] = Query(1, alias='maxResults'),
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    brief: Optional[bool] = False,
    set_back: Optional[int] = Query(0, alias='setBack'),
):
    """
    Find occupants of sites near to a geographic point
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/occupants/nearest.{outputFormat}',
    description=""" Represents the closest occupant to a given point """,
    tags=['occupant_information', 'site_search'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_occupants_nearest__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    point: str = ...,
    max_distance: Optional[int] = Query(None, alias='maxDistance'),
    tags: Optional[str] = None,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    brief: Optional[bool] = False,
    set_back: Optional[int] = Query(0, alias='setBack'),
):
    """
    Find occupants of the site nearest to a geographic point
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/occupants/within.{outputFormat}',
    description=""" Represents all occupants within a given area """,
    tags=['site_search', 'occupant_information'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_occupants_within__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    bbox: str = ...,
    tags: Optional[str] = None,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    max_results: Optional[int] = Query(200, alias='maxResults'),
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    brief: Optional[bool] = False,
    set_back: Optional[int] = Query(0, alias='setBack'),
):
    """
    Find occupants of sites in a geographic area
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/occupants/{occupantID}.{outputFormat}',
    description=""" Represents an individual occupant """,
    tags=['occupant_information', 'site_search'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_occupants__occupant_i_d__output_format(
    occupant_i_d: str = Path(..., alias='occupantID'),
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    brief: Optional[bool] = False,
    set_back: Optional[int] = Query(0, alias='setBack'),
):
    """
    Get an occupant (of a site) by its unique ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/parcels/pids/{siteID}.{outputFormat}',
    description=""" Represents all parcel identifiers associated with an individual site """,
    tags=['site_search', 'parcel_retrieval'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_parcels_pids__site_i_d__output_format(
    site_i_d: str = Path(..., alias='siteID'),
    output_format: OutputFormat = Path(..., alias='outputFormat'),
):
    """
    Get a comma-separated string of all pids for a given site
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sites/near.{outputFormat}',
    description=""" Represents sites near a given point in the order of closest to farthest """,
    tags=['site_search'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_sites_near__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    point: str = ...,
    max_distance: Optional[int] = Query(None, alias='maxDistance'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    max_results: Optional[int] = Query(1, alias='maxResults'),
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    set_back: Optional[int] = Query(0, alias='setBack'),
    brief: Optional[bool] = False,
    exclude_units: Optional[bool] = Query(False, alias='excludeUnits'),
    only_civic: Optional[bool] = Query(False, alias='onlyCivic'),
):
    """
    Find sites near to a geographic point
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sites/nearest.{outputFormat}',
    description=""" Represents the site nearest a given point """,
    tags=['site_search', 'intersection_search'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_sites_nearest__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    point: str = ...,
    max_distance: Optional[int] = Query(None, alias='maxDistance'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    set_back: Optional[int] = Query(0, alias='setBack'),
    brief: Optional[bool] = False,
    exclude_units: Optional[bool] = Query(False, alias='excludeUnits'),
    only_civic: Optional[bool] = Query(False, alias='onlyCivic'),
):
    """
    Find the site nearest to a geographic point
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sites/within.{outputFormat}',
    description=""" Represents sites within a given area """,
    tags=['site_search', 'intersection_search'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_sites_within__output_format(
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    bbox: str = ...,
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    max_results: Optional[int] = Query(1, alias='maxResults'),
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    set_back: Optional[int] = Query(0, alias='setBack'),
    brief: Optional[bool] = False,
    exclude_units: Optional[bool] = Query(False, alias='excludeUnits'),
    only_civic: Optional[bool] = Query(False, alias='onlyCivic'),
):
    """
    Find sites in a geographic area
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sites/{siteID}.{outputFormat}',
    description=""" Represents an individual site """,
    tags=['site_search', 'parcel_retrieval'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_sites__site_i_d__output_format(
    site_i_d: str = Path(..., alias='siteID'),
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    brief: Optional[bool] = False,
    set_back: Optional[int] = Query(0, alias='setBack'),
):
    """
    Get a site by its unique ID
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/sites/{siteID}/subsites.{outputFormat}',
    description=""" Represents all subsites of a given site """,
    tags=['site_search'],
    security=[
        APIKeyHeader(name="apikey"),
    ],
)
def get_sites__site_i_d_subsites__output_format(
    site_i_d: str = Path(..., alias='siteID'),
    output_format: OutputFormat = Path(..., alias='outputFormat'),
    output_s_r_s: Optional[OutputSRS] = Query(4326, alias='outputSRS'),
    location_descriptor: Optional[LocationDescriptor] = Query(
        'any', alias='locationDescriptor'
    ),
    brief: Optional[bool] = False,
    set_back: Optional[int] = Query(0, alias='setBack'),
):
    """
    Represents all subsites of a given site
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
